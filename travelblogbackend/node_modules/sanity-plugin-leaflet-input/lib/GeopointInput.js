"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _leaflet = _interopRequireDefault(require("leaflet"));

var _reactLeaflet = require("react-leaflet");

var _default2 = _interopRequireDefault(require("part:@sanity/components/buttons/default"));

var _default3 = _interopRequireDefault(require("part:@sanity/components/fieldsets/default"));

var _patchEvent = require("part:@sanity/form-builder/patch-event");

var _configLeafletInput = _interopRequireDefault(require("config:leaflet-input"));

var _Leaflet = _interopRequireDefault(require("./Leaflet.css"));

var _GeopointInput = _interopRequireDefault(require("./GeopointInput.css"));

var _GeoSearchPlugin = _interopRequireDefault(require("./GeoSearchPlugin"));

var _MapBoxAccessTokenMissing = _interopRequireDefault(require("./MapBoxAccessTokenMissing"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

_leaflet.default.Icon.Default.mergeOptions({
  iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),
  iconUrl: require('leaflet/dist/images/marker-icon.png'),
  shadowUrl: require('leaflet/dist/images/marker-shadow.png')
});

var EMPTY_MARKERS = [];
var DEFAULT_ZOOM = 13;
var DEFAULT_CENTER = [37.779048, -122.415214];
var clickToMove = typeof window !== 'undefined' && typeof window.matchMedia === 'function' && !matchMedia('(pointer:fine)').matches;

function getKeyPlaceholder(url) {
  var _ref = url.match(/access_token=\{(.*?)\}/) || [],
      _ref2 = _slicedToArray(_ref, 2),
      key = _ref2[1];

  return key;
}

function isMissingMapboxApiKey(tileConfig) {
  var url = tileConfig.url || '';
  var hasStaticAccessKey = /accessToken=[^{]/.test(url);
  var keyPlaceholder = !hasStaticAccessKey && getKeyPlaceholder(url);
  return url.includes('tiles.mapbox.com') && keyPlaceholder && !tileConfig[keyPlaceholder];
}

function getHelpText(value) {
  if (!value || !value.lat) {
    return "Click on map to set location";
  }

  if (clickToMove) {
    return "Click on map to change location. Click marker to remove it.";
  }

  return "Drag marker to change location. Click marker to remove it.";
} // eslint-disable-next-line prefer-arrow-callback


var GeopointInput = /*#__PURE__*/_react.default.forwardRef(function GeopointInput(props, ref) {
  var _type$options;

  var type = props.type,
      level = props.level,
      value = props.value,
      markers = props.markers,
      onChange = props.onChange;
  var typeOptions = ((_type$options = type.options) === null || _type$options === void 0 ? void 0 : _type$options.leaflet) || {};

  var tileConfig = _objectSpread(_objectSpread({}, _configLeafletInput.default.tileLayer), typeOptions.tileLayer);

  var center = value || typeOptions.defaultLocation || _configLeafletInput.default.defaultLocation || DEFAULT_CENTER;

  var _useState = (0, _react.useState)(typeOptions.defaultZoom || _configLeafletInput.default.defaultZoom || DEFAULT_ZOOM),
      _useState2 = _slicedToArray(_useState, 2),
      zoom = _useState2[0],
      setZoom = _useState2[1];

  var markerRef = /*#__PURE__*/(0, _react.createRef)();

  if (isMissingMapboxApiKey(tileConfig)) {
    return /*#__PURE__*/_react.default.createElement(_default3.default, {
      legend: type.title,
      description: type.description,
      markers: markers,
      label: level
    }, /*#__PURE__*/_react.default.createElement(_MapBoxAccessTokenMissing.default, null));
  }

  function setMarkerLocation(latLng) {
    onChange(_patchEvent.PatchEvent.from([(0, _patchEvent.setIfMissing)({
      _type: type.name
    }), (0, _patchEvent.set)(latLng.lat, ['lat']), (0, _patchEvent.set)(latLng.lng, ['lng'])]));
  }

  function handleMapClick(evt) {
    if (!clickToMove && value && value.lat) {
      return;
    }

    setMarkerLocation(evt.latlng);
  }

  function handleMarkerDragEnd() {
    if (!markerRef.current) {
      return;
    }

    setMarkerLocation(markerRef.current.leafletElement.getLatLng());
  }

  function handleUnsetMarker() {
    onChange(_patchEvent.PatchEvent.from((0, _patchEvent.unset)()));
  }

  function onZoom(evt) {
    setZoom(evt.target.getZoom());
  }

  return /*#__PURE__*/_react.default.createElement(_default3.default, {
    legend: type.title,
    description: type.description,
    markers: markers,
    level: level
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: _Leaflet.default.leaflet
  }, /*#__PURE__*/_react.default.createElement(_reactLeaflet.Map, {
    ref: ref,
    className: _GeopointInput.default.map,
    center: center,
    zoom: zoom,
    zoomControl: false,
    onZoomEnd: onZoom,
    scrollWheelZoom: false,
    onClick: handleMapClick,
    trackResize: true
  }, /*#__PURE__*/_react.default.createElement(_reactLeaflet.TileLayer, tileConfig), value && value.lat && /*#__PURE__*/_react.default.createElement(_reactLeaflet.Marker, {
    draggable: !type.readOnly,
    onDragend: handleMarkerDragEnd,
    position: center,
    ref: markerRef
  }, !type.readOnly && /*#__PURE__*/_react.default.createElement(_reactLeaflet.Popup, null, /*#__PURE__*/_react.default.createElement(_default2.default, {
    color: "danger",
    inverted: true,
    onClick: handleUnsetMarker
  }, "Remove point"))), /*#__PURE__*/_react.default.createElement(_GeoSearchPlugin.default, {
    onSelectLocation: setMarkerLocation
  }), /*#__PURE__*/_react.default.createElement(_reactLeaflet.ZoomControl, {
    position: "topright"
  })), /*#__PURE__*/_react.default.createElement("p", {
    className: _GeopointInput.default.helpText
  }, getHelpText(value))));
});

GeopointInput.propTypes = {
  value: _propTypes.default.shape({
    _type: _propTypes.default.string.isRequired,
    lat: _propTypes.default.number.isRequired,
    lng: _propTypes.default.number.isRequired
  }),
  level: _propTypes.default.number.isRequired,
  onChange: _propTypes.default.func.isRequired,
  type: _propTypes.default.shape({
    name: _propTypes.default.string.isRequired,
    title: _propTypes.default.string,
    description: _propTypes.default.string,
    readOnly: _propTypes.default.bool,
    options: _propTypes.default.shape({
      leaflet: _propTypes.default.shape({
        tileLayer: _propTypes.default.shape({
          url: _propTypes.default.string.isRequired,
          maxZoom: _propTypes.default.number,
          attribution: _propTypes.default.string,
          accessToken: _propTypes.default.string
        }),
        defaultLocation: _propTypes.default.shape({
          lat: _propTypes.default.number,
          lng: _propTypes.default.number
        }),
        defaultZoom: _propTypes.default.number
      })
    })
  }).isRequired,
  markers: _propTypes.default.arrayOf(_propTypes.default.shape({
    type: _propTypes.default.string
  }))
};
GeopointInput.defaultProps = {
  value: undefined,
  markers: EMPTY_MARKERS
};
var _default = GeopointInput;
exports.default = _default;
//# sourceMappingURL=GeopointInput.js.map